kubectl create ns keda --dry-run=client -o yaml | kubectl apply -f - && \
kubectl create ns messaging --dry-run=client -o yaml | kubectl apply -f - && \
kubectl create ns default --dry-run=client -o yaml | kubectl apply -f - && \

# 1️⃣ Install KEDA
helm repo add kedacore https://kedacore.github.io/charts && \
helm repo update && \
helm install keda kedacore/keda -n keda && \

# 2️⃣ Install RabbitMQ (Bitnami chart)
helm repo add bitnami https://charts.bitnami.com/bitnami && \
helm repo update && \
helm install rabbitmq bitnami/rabbitmq \
  --namespace messaging \
  --set auth.username=guest,auth.password=guest && \

# 3️⃣ Wait for RabbitMQ to be ready
echo "Waiting for RabbitMQ pod to be ready..." && \
kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=rabbitmq -n messaging --timeout=180s && \

# 4️⃣ Deploy a sample consumer app (Python image)
kubectl apply -f - <<'EOF'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rabbit-consumer
  namespace: default
spec:
  replicas: 0
  selector:
    matchLabels:
      app: rabbit-consumer
  template:
    metadata:
      labels:
        app: rabbit-consumer
    spec:
      containers:
      - name: consumer
        image: ghcr.io/kedacore/tests-rabbitmq-consumer:latest
        env:
        - name: RABBITMQ_URL
          value: "amqp://guest:guest@rabbitmq.messaging.svc.cluster.local:5672/"
        resources:
          requests:
            cpu: "100m"
            memory: "128Mi"
EOF

# 5️⃣ Create RabbitMQ connection Secret and TriggerAuthentication + ScaledObject
kubectl apply -f - <<'EOF'
apiVersion: v1
kind: Secret
metadata:
  name: rabbitmq-conn
  namespace: default
stringData:
  connectionString: "amqp://guest:guest@rabbitmq.messaging.svc.cluster.local:5672/"
---
apiVersion: keda.sh/v1alpha1
kind: TriggerAuthentication
metadata:
  name: rabbitmq-auth
  namespace: default
spec:
  secretTargetRef:
  - parameter: connection
    name: rabbitmq-conn
    key: connectionString
---
apiVersion: keda.sh/v1alpha1
kind: ScaledObject
metadata:
  name: rabbitmq-scaledobject
  namespace: default
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: rabbit-consumer
  pollingInterval: 15
  cooldownPeriod: 30
  minReplicaCount: 0
  maxReplicaCount: 10
  triggers:
  - type: rabbitmq
    metadata:
      queueName: myqueue
      mode: QueueLength
      value: "5"
    authenticationRef:
      name: rabbitmq-auth
EOF

# 6️⃣ Publish 100 messages to RabbitMQ to trigger scaling
kubectl apply -f - <<'EOF'
apiVersion: batch/v1
kind: Job
metadata:
  name: publish-job
  namespace: messaging
spec:
  template:
    spec:
      containers:
      - name: publisher
        image: python:3.11
        command: ["python", "-c"]
        args:
        - |
          import pika
          conn = pika.BlockingConnection(pika.URLParameters('amqp://guest:guest@rabbitmq.messaging.svc.cluster.local:5672/'))
          ch = conn.channel()
          ch.queue_declare(queue='myqueue', durable=True)
          for i in range(100):
              ch.basic_publish(exchange='', routing_key='myqueue', body=f'msg-{i}')
          print("✅ Published 100 messages")
          conn.close()
      restartPolicy: Never
  backoffLimit: 1
EOF

# 7️⃣ Wait a few seconds, then show the scaling behavior
echo "⏳ Waiting for KEDA to detect queue load..." && sleep 45 && \
kubectl get pods -n default && \
kubectl get hpa -n default && \
kubectl get scaledobject -n default
